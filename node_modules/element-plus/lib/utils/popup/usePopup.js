import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _extends from "@babel/runtime/helpers/extends";
import { nextTick, reactive, onBeforeMount, onBeforeUnmount, getCurrentInstance, watch, toRefs } from 'vue';
import PopupManager from "../popup-manager";
import getScrollBarWidth from "../scrollbar-width";
import { getStyle, addClass, removeClass, hasClass } from "../dom";
import isServer from "../isServer";
var idSeed = 1;
var scrollBarWidth;

var usePopup = function usePopup(props, doClose, rootRef) {
  if (rootRef === void 0) {
    rootRef = 'root';
  }

  var _popupId;

  var _opening = false;
  var _closing = false;
  var _closeTimer = null;
  var _openTimer = null;
  var vm = getCurrentInstance();
  var state = reactive({
    opened: false,
    bodyPaddingRight: null,
    computedBodyPaddingRight: 0,
    withoutHiddenClass: true,
    rendered: false,
    visible: false
  });
  onBeforeMount(function () {
    var _ref = vm.proxy,
        handleClose = _ref.handleClose,
        handleAction = _ref.handleAction;
    _popupId = 'popup-' + idSeed++;
    PopupManager.register(_popupId, _extends({}, toRefs(props), {
      close: close,
      handleClose: handleClose,
      handleAction: handleAction
    }));
  });
  onBeforeUnmount(function () {
    PopupManager.deregister(_popupId);
    PopupManager.closeModal(_popupId);
    restoreBodyStyle();
  });

  var doOpen = function doOpen(merProps) {
    if (isServer) return;
    if (state.opened) return;
    _opening = true; // `vm.vnode.el` will be a comment node when using `Teleport`

    var dom = vm.refs[rootRef];
    var modal = merProps.modal;
    var zIndex = merProps.zIndex;

    if (zIndex) {
      PopupManager.zIndex = zIndex;
    }

    if (modal) {
      if (_closing) {
        PopupManager.closeModal(_popupId);
        _closing = false;
      }

      PopupManager.openModal(_popupId, PopupManager.nextZIndex(), props.modalAppendToBody ? undefined : dom, merProps.modalClass, merProps.modalFade);

      if (merProps.lockScroll) {
        state.withoutHiddenClass = !hasClass(document.body, 'el-popup-parent--hidden');

        if (state.withoutHiddenClass) {
          state.bodyPaddingRight = document.body.style.paddingRight;
          state.computedBodyPaddingRight = parseInt(getStyle(document.body, 'paddingRight'), 10);
        }

        scrollBarWidth = getScrollBarWidth();
        var bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
        var bodyOverflowY = getStyle(document.body, 'overflowY');

        if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll') && state.withoutHiddenClass) {
          document.body.style.paddingRight = state.computedBodyPaddingRight + scrollBarWidth + 'px';
        }

        addClass(document.body, 'el-popup-parent--hidden');
      }
    }

    if (getComputedStyle(dom).position === 'static') {
      dom.style.position = 'absolute';
    }

    dom.style.zIndex = String(PopupManager.nextZIndex());
    state.opened = true;
    doAfterOpen();
  };

  var open = function open(options) {
    if (!state.rendered) {
      state.rendered = true;
    }

    var _props = Object.assign({}, props || vm.proxy, options);

    if (_closeTimer) {
      clearTimeout(_closeTimer);
      _closeTimer = null;
    }

    clearTimeout(_openTimer);
    var openDelay = Number(_props.openDelay);

    if (openDelay > 0) {
      _openTimer = setTimeout(function () {
        _openTimer = null;
        doOpen(_props);
      }, openDelay);
    } else {
      doOpen(_props);
    }
  };

  var close = function close() {
    if (_openTimer !== null) {
      clearTimeout(_openTimer);
      _openTimer = null;
    }

    clearTimeout(_closeTimer);
    var closeDelay = Number(props.closeDelay);

    if (closeDelay > 0) {
      _closeTimer = setTimeout(function () {
        _closeTimer = null;
        doClose();
      }, closeDelay);
    } else {
      doClose();
    }
  };

  var doAfterOpen = function doAfterOpen() {
    _opening = false;
  };

  var restoreBodyStyle = function restoreBodyStyle() {
    if (props.modal && state.withoutHiddenClass) {
      document.body.style.paddingRight = state.bodyPaddingRight;
      removeClass(document.body, 'el-popup-parent--hidden');
    }

    state.withoutHiddenClass = true;
  };

  var doAfterClose = function doAfterClose() {
    PopupManager.closeModal(_popupId);
    _closing = false;
  };

  var updateClosingFlag = function updateClosingFlag(value) {
    _closing = value;
  };

  watch(function () {
    return state.visible;
  }, /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(val) {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!val) {
                _context.next = 13;
                break;
              }

              if (!_opening) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return");

            case 3:
              if (state.rendered) {
                _context.next = 10;
                break;
              }

              state.rendered = true;
              _context.next = 7;
              return nextTick();

            case 7:
              open();
              _context.next = 11;
              break;

            case 10:
              open();

            case 11:
              _context.next = 14;
              break;

            case 13:
              close();

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }());
  return {
    state: state,
    open: open,
    close: close,
    doAfterClose: doAfterClose,
    updateClosingFlag: updateClosingFlag,
    restoreBodyStyle: restoreBodyStyle
  };
};

export default usePopup;